"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
var gemini_exports = {};
__export(gemini_exports, {
  GeminiConfigSchema: () => GeminiConfigSchema,
  SUPPORTED_GEMINI_MODELS: () => SUPPORTED_GEMINI_MODELS,
  SUPPORTED_V15_MODELS: () => SUPPORTED_V15_MODELS,
  SUPPORTED_V1_MODELS: () => SUPPORTED_V1_MODELS,
  cleanSchema: () => cleanSchema,
  defineGeminiModel: () => defineGeminiModel,
  fromGeminiCandidate: () => fromGeminiCandidate,
  gemini10Pro: () => gemini10Pro,
  gemini15Flash: () => gemini15Flash,
  gemini15Pro: () => gemini15Pro,
  toGeminiMessage: () => toGeminiMessage,
  toGeminiSystemInstruction: () => toGeminiSystemInstruction
});
module.exports = __toCommonJS(gemini_exports);
var import_vertexai = require("@google-cloud/vertexai");
var import_genkit = require("genkit");
var import_model = require("genkit/model");
var import_middleware = require("genkit/model/middleware");
const SafetySettingsSchema = import_genkit.z.object({
  category: import_genkit.z.nativeEnum(import_vertexai.HarmCategory),
  threshold: import_genkit.z.nativeEnum(import_vertexai.HarmBlockThreshold)
});
const VertexRetrievalSchema = import_genkit.z.object({
  datastore: import_genkit.z.object({
    projectId: import_genkit.z.string().optional(),
    location: import_genkit.z.string().optional(),
    dataStoreId: import_genkit.z.string()
  }),
  disableAttribution: import_genkit.z.boolean().optional()
});
const GoogleSearchRetrievalSchema = import_genkit.z.object({
  disableAttribution: import_genkit.z.boolean().optional()
});
const GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({
  safetySettings: import_genkit.z.array(SafetySettingsSchema).optional(),
  location: import_genkit.z.string().optional(),
  vertexRetrieval: VertexRetrievalSchema.optional(),
  googleSearchRetrieval: GoogleSearchRetrievalSchema.optional(),
  functionCallingConfig: import_genkit.z.object({
    mode: import_genkit.z.enum(["MODE_UNSPECIFIED", "AUTO", "ANY", "NONE"]).optional(),
    allowedFunctionNames: import_genkit.z.array(import_genkit.z.string()).optional()
  }).optional()
});
const gemini10Pro = (0, import_model.modelRef)({
  name: "vertexai/gemini-1.0-pro",
  info: {
    label: "Vertex AI - Gemini Pro",
    versions: ["gemini-1.0-pro-001", "gemini-1.0-pro-002"],
    supports: {
      multiturn: true,
      media: false,
      tools: true,
      systemRole: true
    }
  },
  configSchema: GeminiConfigSchema
});
const gemini15Pro = (0, import_model.modelRef)({
  name: "vertexai/gemini-1.5-pro",
  info: {
    label: "Vertex AI - Gemini 1.5 Pro",
    versions: ["gemini-1.5-pro-001", "gemini-1.5-pro-002"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true
    }
  },
  configSchema: GeminiConfigSchema
});
const gemini15Flash = (0, import_model.modelRef)({
  name: "vertexai/gemini-1.5-flash",
  info: {
    label: "Vertex AI - Gemini 1.5 Flash",
    versions: ["gemini-1.5-flash-001", "gemini-1.5-flash-002"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true
    }
  },
  configSchema: GeminiConfigSchema
});
const SUPPORTED_V1_MODELS = {
  "gemini-1.0-pro": gemini10Pro
};
const SUPPORTED_V15_MODELS = {
  "gemini-1.5-pro": gemini15Pro,
  "gemini-1.5-flash": gemini15Flash
};
const SUPPORTED_GEMINI_MODELS = __spreadValues(__spreadValues({}, SUPPORTED_V1_MODELS), SUPPORTED_V15_MODELS);
function toGeminiRole(role, model) {
  switch (role) {
    case "user":
      return "user";
    case "model":
      return "model";
    case "system":
      if (model && SUPPORTED_V15_MODELS[model.name]) {
        throw new Error(
          "system role is only supported for a single message in the first position"
        );
      } else {
        throw new Error("system role is not supported");
      }
    case "tool":
      return "function";
    default:
      return "user";
  }
}
const toGeminiTool = (tool) => {
  const declaration = {
    name: tool.name.replace(/\//g, "__"),
    // Gemini throws on '/' in tool name
    description: tool.description,
    parameters: convertSchemaProperty(tool.inputSchema)
  };
  return declaration;
};
const toGeminiFileDataPart = (part) => {
  const media = part.media;
  if (media.url.startsWith("gs://")) {
    if (!media.contentType)
      throw new Error(
        "Must supply contentType when using media from gs:// URLs."
      );
    return {
      fileData: {
        mimeType: media.contentType,
        fileUri: media.url
      }
    };
  } else if (media.url.startsWith("data:")) {
    const dataUrl = media.url;
    const b64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);
    const contentType = media.contentType || dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
    return { inlineData: { mimeType: contentType, data: b64Data } };
  }
  throw Error(
    "Could not convert genkit part to gemini tool response part: missing file data"
  );
};
const toGeminiToolRequestPart = (part) => {
  var _a;
  if (!((_a = part == null ? void 0 : part.toolRequest) == null ? void 0 : _a.input)) {
    throw Error(
      "Could not convert genkit part to gemini tool response part: missing tool request data"
    );
  }
  return {
    functionCall: {
      name: part.toolRequest.name,
      args: part.toolRequest.input
    }
  };
};
const toGeminiToolResponsePart = (part) => {
  var _a;
  if (!((_a = part == null ? void 0 : part.toolResponse) == null ? void 0 : _a.output)) {
    throw Error(
      "Could not convert genkit part to gemini tool response part: missing tool response data"
    );
  }
  return {
    functionResponse: {
      name: part.toolResponse.name,
      response: {
        name: part.toolResponse.name,
        content: part.toolResponse.output
      }
    }
  };
};
function toGeminiSystemInstruction(message) {
  return {
    role: "user",
    parts: message.content.map(toGeminiPart)
  };
}
function toGeminiMessage(message, model) {
  return {
    role: toGeminiRole(message.role, model),
    parts: message.content.map(toGeminiPart)
  };
}
function fromGeminiFinishReason(reason) {
  if (!reason) return "unknown";
  switch (reason) {
    case "STOP":
      return "stop";
    case "MAX_TOKENS":
      return "length";
    case "SAFETY":
    // blocked for safety
    case "RECITATION":
      return "blocked";
    default:
      return "unknown";
  }
}
function toGeminiPart(part) {
  if (part.text) {
    return { text: part.text };
  } else if (part.media) {
    return toGeminiFileDataPart(part);
  } else if (part.toolRequest) {
    return toGeminiToolRequestPart(part);
  } else if (part.toolResponse) {
    return toGeminiToolResponsePart(part);
  } else {
    throw new Error("unsupported type");
  }
}
function fromGeminiInlineDataPart(part) {
  if (!part.inlineData || !part.inlineData.hasOwnProperty("mimeType") || !part.inlineData.hasOwnProperty("data")) {
    throw new Error("Invalid GeminiPart: missing required properties");
  }
  const { mimeType, data } = part.inlineData;
  const dataUrl = `data:${mimeType};base64,${data}`;
  return {
    media: {
      url: dataUrl,
      contentType: mimeType
    }
  };
}
function fromGeminiFileDataPart(part) {
  var _a, _b;
  if (!part.fileData || !part.fileData.hasOwnProperty("mimeType") || !part.fileData.hasOwnProperty("url")) {
    throw new Error(
      "Invalid Gemini File Data Part: missing required properties"
    );
  }
  return {
    media: {
      url: (_a = part.fileData) == null ? void 0 : _a.fileUri,
      contentType: (_b = part.fileData) == null ? void 0 : _b.mimeType
    }
  };
}
function fromGeminiFunctionCallPart(part) {
  if (!part.functionCall) {
    throw new Error(
      "Invalid Gemini Function Call Part: missing function call data"
    );
  }
  return {
    toolRequest: {
      name: part.functionCall.name,
      input: part.functionCall.args
    }
  };
}
function fromGeminiFunctionResponsePart(part) {
  if (!part.functionResponse) {
    throw new Error(
      "Invalid Gemini Function Call Part: missing function call data"
    );
  }
  return {
    toolResponse: {
      name: part.functionResponse.name.replace(/__/g, "/"),
      // restore slashes
      output: part.functionResponse.response
    }
  };
}
function fromGeminiPart(part, jsonMode) {
  if (part.text !== void 0) return { text: part.text };
  if (part.functionCall) return fromGeminiFunctionCallPart(part);
  if (part.functionResponse) return fromGeminiFunctionResponsePart(part);
  if (part.inlineData) return fromGeminiInlineDataPart(part);
  if (part.fileData) return fromGeminiFileDataPart(part);
  throw new Error(
    "Part type is unsupported/corrupted. Either data is missing or type cannot be inferred from type."
  );
}
function fromGeminiCandidate(candidate, jsonMode) {
  const parts = candidate.content.parts || [];
  const genkitCandidate = {
    index: candidate.index || 0,
    // reasonable default?
    message: {
      role: "model",
      content: parts.map((p) => fromGeminiPart(p, jsonMode))
    },
    finishReason: fromGeminiFinishReason(candidate.finishReason),
    finishMessage: candidate.finishMessage,
    custom: {
      safetyRatings: candidate.safetyRatings,
      citationMetadata: candidate.citationMetadata
    }
  };
  return genkitCandidate;
}
const convertSchemaProperty = (property) => {
  if (!property || !property.type) {
    return null;
  }
  if (property.type === "object") {
    const nestedProperties = {};
    Object.keys(property.properties).forEach((key) => {
      nestedProperties[key] = convertSchemaProperty(property.properties[key]);
    });
    return {
      type: import_vertexai.FunctionDeclarationSchemaType.OBJECT,
      properties: nestedProperties,
      required: property.required
    };
  } else if (property.type === "array") {
    return {
      type: import_vertexai.FunctionDeclarationSchemaType.ARRAY,
      items: convertSchemaProperty(property.items)
    };
  } else {
    return {
      type: import_vertexai.FunctionDeclarationSchemaType[property.type.toUpperCase()]
    };
  }
};
function cleanSchema(schema) {
  const out = structuredClone(schema);
  for (const key in out) {
    if (key === "$schema" || key === "additionalProperties") {
      delete out[key];
      continue;
    }
    if (typeof out[key] === "object") {
      out[key] = cleanSchema(out[key]);
    }
    if (key === "type" && Array.isArray(out[key])) {
      out[key] = out[key].find((t) => t !== "null");
    }
  }
  return out;
}
function defineGeminiModel(ai, name, vertexClientFactory, options) {
  var _a, _b;
  const modelName = `vertexai/${name}`;
  const model = SUPPORTED_GEMINI_MODELS[name];
  if (!model) throw new Error(`Unsupported model: ${name}`);
  const middlewares = [];
  if (SUPPORTED_V1_MODELS[name]) {
    middlewares.push((0, import_middleware.simulateSystemPrompt)());
  }
  if ((_b = (_a = model == null ? void 0 : model.info) == null ? void 0 : _a.supports) == null ? void 0 : _b.media) {
    middlewares.push((0, import_middleware.downloadRequestMedia)({ maxBytes: 1024 * 1024 * 20 }));
  }
  return ai.defineModel(
    __spreadProps(__spreadValues({
      name: modelName
    }, model.info), {
      configSchema: GeminiConfigSchema,
      use: middlewares
    }),
    (request, streamingCallback) => __async(this, null, function* () {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
      const vertex = vertexClientFactory(request);
      const client = vertex.preview.getGenerativeModel(
        {
          model: ((_a2 = request.config) == null ? void 0 : _a2.version) || model.version || name
        },
        {
          apiClient: import_genkit.GENKIT_CLIENT_HEADER
        }
      );
      const messages = [...request.messages];
      if (messages.length === 0) throw new Error("No messages provided.");
      let systemInstruction = void 0;
      if (SUPPORTED_V15_MODELS[name]) {
        const systemMessage = messages.find((m) => m.role === "system");
        if (systemMessage) {
          messages.splice(messages.indexOf(systemMessage), 1);
          systemInstruction = toGeminiSystemInstruction(systemMessage);
        }
      }
      const tools = ((_b2 = request.tools) == null ? void 0 : _b2.length) ? [{ functionDeclarations: (_c = request.tools) == null ? void 0 : _c.map(toGeminiTool) }] : [];
      let toolConfig;
      if ((_d = request == null ? void 0 : request.config) == null ? void 0 : _d.functionCallingConfig) {
        toolConfig = {
          functionCallingConfig: {
            allowedFunctionNames: request.config.functionCallingConfig.allowedFunctionNames,
            mode: toGeminiFunctionMode(
              request.config.functionCallingConfig.mode
            )
          }
        };
      }
      const jsonMode = (((_e = request.output) == null ? void 0 : _e.format) === "json" || !!((_f = request.output) == null ? void 0 : _f.schema)) && tools.length === 0;
      const chatRequest = {
        systemInstruction,
        tools,
        toolConfig,
        history: messages.slice(0, -1).map((message) => toGeminiMessage(message, model)),
        generationConfig: {
          candidateCount: request.candidates || void 0,
          temperature: (_g = request.config) == null ? void 0 : _g.temperature,
          maxOutputTokens: (_h = request.config) == null ? void 0 : _h.maxOutputTokens,
          topK: (_i = request.config) == null ? void 0 : _i.topK,
          topP: (_j = request.config) == null ? void 0 : _j.topP,
          responseMimeType: jsonMode ? "application/json" : void 0,
          stopSequences: (_k = request.config) == null ? void 0 : _k.stopSequences
        },
        safetySettings: (_l = request.config) == null ? void 0 : _l.safetySettings
      };
      if (jsonMode && ((_m = request.output) == null ? void 0 : _m.constrained)) {
        chatRequest.generationConfig.responseSchema = cleanSchema(
          request.output.schema
        );
      }
      if ((_n = request.config) == null ? void 0 : _n.googleSearchRetrieval) {
        (_o = chatRequest.tools) == null ? void 0 : _o.push({
          googleSearchRetrieval: request.config.googleSearchRetrieval
        });
      }
      if ((_p = request.config) == null ? void 0 : _p.vertexRetrieval) {
        const vertexRetrieval = request.config.vertexRetrieval;
        const _projectId = vertexRetrieval.datastore.projectId || options.projectId;
        const _location = vertexRetrieval.datastore.location || options.location;
        const _dataStoreId = vertexRetrieval.datastore.dataStoreId;
        const datastore = `projects/${_projectId}/locations/${_location}/collections/default_collection/dataStores/${_dataStoreId}`;
        (_q = chatRequest.tools) == null ? void 0 : _q.push({
          retrieval: {
            vertexAiSearch: {
              datastore
            },
            disableAttribution: vertexRetrieval.disableAttribution
          }
        });
      }
      const msg = toGeminiMessage(messages[messages.length - 1], model);
      if (streamingCallback) {
        const result = yield client.startChat(chatRequest).sendMessageStream(msg.parts);
        try {
          for (var iter = __forAwait(result.stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const item = temp.value;
            (_r = item.candidates) == null ? void 0 : _r.forEach((candidate) => {
              const c = fromGeminiCandidate(candidate, jsonMode);
              streamingCallback({
                index: c.index,
                content: c.message.content
              });
            });
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        const response = yield result.response;
        if (!((_s = response.candidates) == null ? void 0 : _s.length)) {
          throw new Error("No valid candidates returned.");
        }
        return {
          candidates: ((_t = response.candidates) == null ? void 0 : _t.map((c) => fromGeminiCandidate(c, jsonMode))) || [],
          custom: response
        };
      } else {
        let result;
        try {
          result = yield client.startChat(chatRequest).sendMessage(msg.parts);
        } catch (err) {
          throw new Error(`Vertex response generation failed: ${err}`);
        }
        if (!((_u = result == null ? void 0 : result.response.candidates) == null ? void 0 : _u.length)) {
          throw new Error("No valid candidates returned.");
        }
        const responseCandidates = ((_v = result.response.candidates) == null ? void 0 : _v.map(
          (c) => fromGeminiCandidate(c, jsonMode)
        )) || [];
        return {
          candidates: responseCandidates,
          custom: result.response,
          usage: __spreadProps(__spreadValues({}, (0, import_model.getBasicUsageStats)(request.messages, responseCandidates)), {
            inputTokens: (_w = result.response.usageMetadata) == null ? void 0 : _w.promptTokenCount,
            outputTokens: (_x = result.response.usageMetadata) == null ? void 0 : _x.candidatesTokenCount,
            totalTokens: (_y = result.response.usageMetadata) == null ? void 0 : _y.totalTokenCount
          })
        };
      }
    })
  );
}
function toGeminiFunctionMode(genkitMode) {
  if (genkitMode === void 0) {
    return void 0;
  }
  switch (genkitMode) {
    case "MODE_UNSPECIFIED": {
      return import_vertexai.FunctionCallingMode.MODE_UNSPECIFIED;
    }
    case "ANY": {
      return import_vertexai.FunctionCallingMode.ANY;
    }
    case "AUTO": {
      return import_vertexai.FunctionCallingMode.AUTO;
    }
    case "NONE": {
      return import_vertexai.FunctionCallingMode.NONE;
    }
    default:
      throw new Error(`unsupported function calling mode: ${genkitMode}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GeminiConfigSchema,
  SUPPORTED_GEMINI_MODELS,
  SUPPORTED_V15_MODELS,
  SUPPORTED_V1_MODELS,
  cleanSchema,
  defineGeminiModel,
  fromGeminiCandidate,
  gemini10Pro,
  gemini15Flash,
  gemini15Pro,
  toGeminiMessage,
  toGeminiSystemInstruction
});
//# sourceMappingURL=gemini.js.map